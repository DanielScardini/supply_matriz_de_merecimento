# Databricks notebook source
# MAGIC %md
# MAGIC # C√°lculo da Matriz de Merecimento - Detec√ß√£o Autom√°tica de Meses At√≠picos
# MAGIC
# MAGIC Este notebook implementa o c√°lculo da matriz de merecimento com detec√ß√£o autom√°tica
# MAGIC de meses at√≠picos usando regra anal√≠tica baseada em estat√≠sticas robustas.
# MAGIC
# MAGIC **Objetivo**: Calcular a matriz de merecimento otimizada removendo meses com comportamento
# MAGIC at√≠pico que podem distorcer as aloca√ß√µes.
# MAGIC
# MAGIC **Metodologia de Detec√ß√£o de Outliers**:
# MAGIC - **Regra dos 3 Desvios Padr√£o**: Remove meses com QtMercadoria > 3œÉ da m√©dia
# MAGIC - **C√°lculo por G√™meo**: Estat√≠sticas calculadas individualmente para cada grupo de produtos similares
# MAGIC - **Valida√ß√£o Autom√°tica**: Identifica e reporta meses removidos com justificativa estat√≠stica

# COMMAND ----------

# MAGIC %md
# MAGIC ## 1. Imports e Configura√ß√µes Iniciais

# COMMAND ----------

from pyspark.sql import SparkSession, DataFrame
from pyspark.sql import functions as F, Window
from datetime import datetime, timedelta
import pandas as pd
from typing import List, Optional

# Inicializa√ß√£o do Spark
spark = SparkSession.builder.appName("calculo_matriz_merecimento").getOrCreate()

# COMMAND ----------

# MAGIC %md
# MAGIC ## 2. Carregamento dos Dados Base

# MAGIC %md
# MAGIC Carregamos a base de dados de vendas e estoque para produtos de telefonia celular,
# MAGIC que ser√° utilizada para o c√°lculo da matriz de merecimento.

# COMMAND ----------

df_vendas_estoque_telefonia = (
    spark.table('databox.bcg_comum.supply_base_merecimento_diario')
    .filter(F.col("NmAgrupamentoDiretoriaSetor") == 'DIRETORIA TELEFONIA CELULAR')
    .filter(F.col("DtAtual") >= "2024-01-01")
    .withColumn(
        "year_month",
        F.date_format(F.col("DtAtual"), "yyyyMM").cast("int")
    )
    .fillna(0, subset=["Receita", "QtMercadoria", "TeveVenda"])
)
df_vendas_estoque_telefonia.cache()

print("‚úÖ Dados de vendas e estoque de telefonia carregados:")
print(f"üìä Total de registros: {df_vendas_estoque_telefonia.count():,}")
print(f"üìÖ Per√≠odo: {df_vendas_estoque_telefonia.agg(F.min('DtAtual'), F.max('DtAtual')).collect()[0]}")

df_vendas_estoque_telefonia.limit(1).display()

# COMMAND ----------

# MAGIC %md
# MAGIC ## 3. Carregamento dos Mapeamentos de Produtos

# MAGIC %md
# MAGIC Carregamos os arquivos de mapeamento que relacionam SKUs com modelos, 
# MAGIC esp√©cies gerenciais e grupos de produtos similares ("g√™meos").

# COMMAND ----------

# Mapeamento de modelos e tecnologia
de_para_modelos_tecnologia = (
    pd.read_csv('dados_analise/MODELOS_AJUSTE (1).csv', 
                delimiter=';')
    .drop_duplicates()
)

# Normaliza√ß√£o de nomes de colunas
de_para_modelos_tecnologia.columns = (
    de_para_modelos_tecnologia.columns
    .str.strip()            # remove leading/trailing spaces
    .str.lower()            # lowercase
    .str.replace(r"[^\w]+", "_", regex=True)  # non-alphanumeric -> "_"
    .str.strip("_")         # remove leading/trailing underscores
)

# Mapeamento de produtos similares (g√™meos)
de_para_gemeos_tecnologia = (
    pd.read_csv('dados_analise/ITENS_GEMEOS 2.csv',
                delimiter=";",
                encoding='iso-8859-1')
    .drop_duplicates()
)

# Normaliza√ß√£o de nomes de colunas
de_para_gemeos_tecnologia.columns = (
    de_para_gemeos_tecnologia
    .columns
    .str.strip()            # remove leading/trailing spaces
    .str.lower()            # lowercase
    .str.replace(r"[^\w]+", "_", regex=True)  # non-alphanumeric -> "_"
    .str.strip("_")         # remove leading/trailing underscores
)

# Renomea√ß√£o e merge dos mapeamentos
de_para_modelos_tecnologia = (
    de_para_modelos_tecnologia.rename(columns={'codigo_item': 'sku_loja'})
)

de_para_modelos_gemeos_tecnologia = (
    spark.createDataFrame(
        pd.merge(
            de_para_modelos_tecnologia,
            de_para_gemeos_tecnologia,
            on='sku_loja',
            how="outer"
        )
        [['sku_loja', 'item', 'modelos', 'setor_gerencial', 'gemeos']]
        .drop_duplicates()
    )
    .withColumnRenamed("sku_loja", "CdSku")
)

print("‚úÖ Mapeamentos de produtos carregados:")
print(f"üì¶ Total de SKUs mapeados: {de_para_modelos_gemeos_tecnologia.count():,}")
print(f"üîÑ Total de grupos g√™meos: {de_para_modelos_gemeos_tecnologia.select('gemeos').distinct().count()}")

de_para_modelos_gemeos_tecnologia.limit(1).display()

# COMMAND ----------

# MAGIC %md
# MAGIC ## 4. Join dos Dados com Mapeamentos

# MAGIC %md
# MAGIC Realizamos o join entre os dados de vendas/estoque e os mapeamentos
# MAGIC para obter uma base consolidada com informa√ß√µes de g√™meos.

# COMMAND ----------

df_vendas_estoque_telefonia_gemeos_modelos = (
    df_vendas_estoque_telefonia
    .join(
        de_para_modelos_gemeos_tecnologia,
        on=['CdSku'],
        how='left'
    )
    .fillna("SEM_GRUPO", subset=["gemeos"])
)

print("‚úÖ Dados consolidados com mapeamentos:")
print(f"üìä Total de registros ap√≥s join: {df_vendas_estoque_telefonia_gemeos_modelos.count():,}")

df_vendas_estoque_telefonia_gemeos_modelos.limit(1).display()

# COMMAND ----------

# MAGIC %md
# MAGIC ## 5. Detec√ß√£o Autom√°tica de Meses At√≠picos

# MAGIC %md
# MAGIC Implementamos a regra anal√≠tica para detectar meses at√≠picos:
# MAGIC - **C√°lculo por G√™meo**: Estat√≠sticas calculadas individualmente para cada grupo de produtos similares
# MAGIC - **Regra dos 3 Desvios**: Remove meses com QtMercadoria > 3œÉ da m√©dia
# MAGIC - **Valida√ß√£o Autom√°tica**: Identifica e reporta meses removidos com justificativa estat√≠stica

# COMMAND ----------

# MAGIC %md
# MAGIC ### 5.1 C√°lculo de Estat√≠sticas por G√™meo e M√™s

# MAGIC %md
# MAGIC Calculamos as estat√≠sticas (m√©dia e desvio padr√£o) da quantidade de mercadoria
# MAGIC para cada grupo de produtos similares (g√™meos) por m√™s.

# COMMAND ----------

# Agrega√ß√£o por g√™meo e m√™s para c√°lculo de estat√≠sticas
df_stats_por_gemeo_mes = (
    df_vendas_estoque_telefonia_gemeos_modelos
    .groupBy("gemeos", "year_month")
    .agg(
        F.sum("QtMercadoria").alias("QtMercadoria_total"),
        F.countDistinct("CdFilial").alias("qtd_filiais"),
        F.countDistinct("CdSku").alias("qtd_skus")
    )
    .filter(F.col("QtMercadoria_total") > 0)  # Remove meses sem vendas
)

print("üìä Estat√≠sticas calculadas por g√™meo e m√™s:")
print(f"üìà Total de registros: {df_stats_por_gemeo_mes.count():,}")

df_stats_por_gemeo_mes.limit(5).display()

# COMMAND ----------

# MAGIC %md
# MAGIC ### 5.2 C√°lculo de M√©dia e Desvio Padr√£o por G√™meo

# MAGIC %md
# MAGIC Calculamos a m√©dia e desvio padr√£o da quantidade de mercadoria para cada g√™meo,
# MAGIC considerando todos os meses dispon√≠veis.

# COMMAND ----------

# Janela para c√°lculo de estat√≠sticas por g√™meo
w_stats_gemeo = Window.partitionBy("gemeos")

# C√°lculo de m√©dia e desvio padr√£o por g√™meo
df_stats_gemeo = (
    df_stats_por_gemeo_mes
    .withColumn(
        "media_qt_mercadoria",
        F.avg("QtMercadoria_total").over(w_stats_gemeo)
    )
    .withColumn(
        "desvio_padrao_qt_mercadoria",
        F.stddev("QtMercadoria_total").over(w_stats_gemeo)
    )
    .withColumn(
        "limite_superior_3sigma",
        F.col("media_qt_mercadoria") + (F.lit(3) * F.col("desvio_padrao_qt_mercadoria"))
    )
    .withColumn(
        "limite_inferior_3sigma",
        F.greatest(
            F.col("media_qt_mercadoria") - (F.lit(3) * F.col("desvio_padrao_qt_mercadoria")),
            F.lit(0)  # N√£o permite valores negativos
        )
    )
    .withColumn(
        "flag_mes_atipico",
        F.when(
            (F.col("QtMercadoria_total") > F.col("limite_superior_3sigma")) |
            (F.col("QtMercadoria_total") < F.col("limite_inferior_3sigma")),
            F.lit(1)
        ).otherwise(F.lit(0))
    )
)

print("üìä Estat√≠sticas calculadas por g√™meo:")
print(f"üìà Total de registros: {df_stats_gemeo.count():,}")

# Mostrar estat√≠sticas para alguns g√™meos
df_stats_gemeo.orderBy("gemeos", "year_month").limit(10).display()

# COMMAND ----------

# MAGIC %md
# MAGIC ### 5.3 Identifica√ß√£o de Meses At√≠picos

# MAGIC %md
# MAGIC Identificamos os meses que ser√£o removidos por serem considerados at√≠picos
# MAGIC segundo a regra dos 3 desvios padr√£o.

# COMMAND ----------

# Meses identificados como at√≠picos
df_meses_atipicos = (
    df_stats_gemeo
    .filter(F.col("flag_mes_atipico") == 1)
    .select(
        "gemeos",
        "year_month",
        F.round("QtMercadoria_total", 2).alias("QtMercadoria_total"),
        F.round("media_qt_mercadoria", 2).alias("media_qt_mercadoria"),
        F.round("desvio_padrao_qt_mercadoria", 2).alias("desvio_padrao_qt_mercadoria"),
        F.round("limite_superior_3sigma", 2).alias("limite_superior_3sigma"),
        F.round("limite_inferior_3sigma", 2).alias("limite_inferior_3sigma"),
        "flag_mes_atipico"
    )
    .orderBy("gemeos", "year_month")
)

print("‚ö†Ô∏è MESES IDENTIFICADOS COMO AT√çPICOS:")
print("=" * 80)
print(f"üìä Total de meses at√≠picos: {df_meses_atipicos.count():,}")

if df_meses_atipicos.count() > 0:
    print("\nüîç Detalhamento dos meses at√≠picos:")
    df_meses_atipicos.display()
else:
    print("‚úÖ Nenhum m√™s at√≠pico foi identificado!")

# COMMAND ----------

# MAGIC %md
# MAGIC ### 5.4 Resumo Estat√≠stico por G√™meo

# MAGIC %md
# MAGIC Apresentamos um resumo estat√≠stico mostrando quantos meses foram identificados
# MAGIC como at√≠picos para cada grupo de produtos similares.

# COMMAND ----------

# Resumo estat√≠stico por g√™meo
df_resumo_atipicos_gemeo = (
    df_stats_gemeo
    .groupBy("gemeos")
    .agg(
        F.count("*").alias("total_meses"),
        F.sum("flag_mes_atipico").alias("meses_atipicos"),
        F.round(F.avg("media_qt_mercadoria"), 2).alias("media_qt_mercadoria"),
        F.round(F.avg("desvio_padrao_qt_mercadoria"), 2).alias("desvio_padrao_qt_mercadoria")
    )
    .withColumn(
        "percentual_meses_atipicos",
        F.round(F.col("meses_atipicos") / F.col("total_meses") * 100, 2)
    )
    .orderBy(F.desc("meses_atipicos"))
)

print("üìã RESUMO ESTAT√çSTICO POR G√äMEO:")
print("=" * 80)
df_resumo_atipicos_gemeo.display()

# COMMAND ----------

# MAGIC %md
# MAGIC ## 6. Filtragem dos Dados - Remo√ß√£o de Meses At√≠picos

# MAGIC %md
# MAGIC Aplicamos o filtro para remover os meses identificados como at√≠picos,
# MAGIC criando uma base limpa para o c√°lculo da matriz de merecimento.

# COMMAND ----------

# Lista de meses at√≠picos para filtro
meses_atipicos_filtro = (
    df_meses_atipicos
    .select("year_month")
    .distinct()
    .collect()
)

meses_atipicos_lista = [row["year_month"] for row in meses_atipicos_filtro]

print("üîç MESES AT√çPICOS IDENTIFICADOS PARA REMO√á√ÉO:")
print("=" * 50)
if meses_atipicos_lista:
    for mes in sorted(meses_atipicos_lista):
        print(f"üìÖ {mes}")
    print(f"\nüìä Total de meses √∫nicos a serem removidos: {len(meses_atipicos_lista)}")
else:
    print("‚úÖ Nenhum m√™s at√≠pico identificado!")

# COMMAND ----------

# MAGIC %md
# MAGIC ### 6.1 Aplica√ß√£o do Filtro de Meses At√≠picos

# MAGIC %md
# MAGIC Aplicamos o filtro para remover os meses at√≠picos da base de dados,
# MAGIC mantendo apenas os meses com comportamento normal para c√°lculo da matriz.

# COMMAND ----------

# Aplica√ß√£o do filtro de meses at√≠picos
df_vendas_estoque_telefonia_filtrado = (
    df_vendas_estoque_telefonia_gemeos_modelos
    .filter(~F.col("year_month").isin(meses_atipicos_lista))
)

print("‚úÖ FILTRO DE MESES AT√çPICOS APLICADO:")
print("=" * 50)
print(f"üìä Total de registros ANTES do filtro: {df_vendas_estoque_telefonia_gemeos_modelos.count():,}")
print(f"üìä Total de registros DEPOIS do filtro: {df_vendas_estoque_telefonia_filtrado.count():,}")
print(f"üìä Registros removidos: {df_vendas_estoque_telefonia_gemeos_modelos.count() - df_vendas_estoque_telefonia_filtrado.count():,}")

# COMMAND ----------

# MAGIC %md
# MAGIC ### 6.2 Valida√ß√£o da Filtragem

# MAGIC %md
# MAGIC Validamos que a filtragem foi aplicada corretamente, verificando
# MAGIC se os meses at√≠picos foram efetivamente removidos.

# COMMAND ----------

# Valida√ß√£o da filtragem
meses_restantes = (
    df_vendas_estoque_telefonia_filtrado
    .select("year_month")
    .distinct()
    .orderBy("year_month")
    .collect()
)

meses_restantes_lista = [row["year_month"] for row in meses_restantes]

print("‚úÖ VALIDA√á√ÉO DA FILTRAGEM:")
print("=" * 50)
print(f"üìä Total de meses restantes: {len(meses_restantes_lista)}")
print(f"üìÖ Meses dispon√≠veis para an√°lise:")
for mes in meses_restantes_lista:
    print(f"  ‚Ä¢ {mes}")

# Verificar se algum m√™s at√≠pico ainda est√° presente
meses_atipicos_ainda_presentes = set(meses_atipicos_lista) & set(meses_restantes_lista)
if meses_atipicos_ainda_presentes:
    print(f"\n‚ö†Ô∏è ATEN√á√ÉO: Meses at√≠picos ainda presentes: {meses_atipicos_ainda_presentes}")
else:
    print(f"\n‚úÖ CONFIRMADO: Todos os meses at√≠picos foram removidos com sucesso!")

# COMMAND ----------

# MAGIC %md
# MAGIC ## 7. Agrega√ß√£o dos Dados Filtrados

# MAGIC %md
# MAGIC Agregamos os dados filtrados por m√™s, modelo, g√™meos e filial para
# MAGIC an√°lise no n√≠vel de loja, agora sem os meses at√≠picos.

# COMMAND ----------

df_vendas_estoque_telefonia_agg_filtrado = (
    df_vendas_estoque_telefonia_filtrado
    .filter(~F.col("NmEspecieGerencial").contains("CHIP"))  # Excluir chips
    .groupBy("year_month", "gemeos", "CdFilial")
    .agg(
        F.sum("QtMercadoria").alias("QtMercadoria"),
        F.round(F.sum("Receita"), 2).alias("Receita"),
        F.round(F.sum("Media90_Qt_venda_estq"), 0).alias("QtdDemanda"),
        F.round(F.median("PrecoMedio90"), 2).alias("PrecoMedio90")
    )
)

print("‚úÖ Dados agregados por filial (sem meses at√≠picos):")
print(f"üìä Total de registros agregados: {df_vendas_estoque_telefonia_agg_filtrado.count():,}")

df_vendas_estoque_telefonia_agg_filtrado.limit(5).display()

# COMMAND ----------

# MAGIC %md
# MAGIC ## 8. C√°lculo de Percentuais para Matriz de Merecimento

# MAGIC %md
# MAGIC Calculamos os percentuais de participa√ß√£o nas vendas e demanda por m√™s,
# MAGIC modelo e grupo de produtos similares, agora com base nos dados filtrados.

# COMMAND ----------

# Janela por m√™s, modelo e g√™meos
w = Window.partitionBy("year_month", "gemeos")

df_pct_telefonia_filtrado = (
    df_vendas_estoque_telefonia_agg_filtrado
    # Totais no m√™s/especie
    .withColumn("Qt_total_mes_especie", F.sum("QtMercadoria").over(w))
    .withColumn("Demanda_total_mes_especie", F.sum("QtdDemanda").over(w))
    
    # Percentuais de venda e demanda
    .withColumn(
        "pct_vendas", 
        F.when(F.col("Qt_total_mes_especie") > 0,
               F.col("QtMercadoria") / F.col("Qt_total_mes_especie"))
         .otherwise(F.lit(None).cast("double"))
    )
    .withColumn(
        "pct_demanda", 
        F.when(F.col("Demanda_total_mes_especie") > 0,
               F.col("QtdDemanda") / F.col("Demanda_total_mes_especie"))
         .otherwise(F.lit(None).cast("double"))
    )
    
    # Percentuais em %
    .withColumn("pct_vendas_perc", F.round(F.col("pct_vendas") * 100, 2))
    .withColumn("pct_demanda_perc", F.round(F.col("pct_demanda") * 100, 2))
    
    # Selecionar colunas finais
    .select(
        "year_month", "gemeos", "CdFilial",
        "QtMercadoria", "QtdDemanda", "PrecoMedio90",
        "Qt_total_mes_especie", "Demanda_total_mes_especie",
        "pct_vendas", "pct_vendas_perc",
        "pct_demanda", "pct_demanda_perc"
    )
    .fillna(0, subset=[
        "Qt_total_mes_especie", "Demanda_total_mes_especie",
        "pct_vendas", "pct_vendas_perc", 
        "pct_demanda", "pct_demanda_perc"
    ])
)

print("‚úÖ Percentuais calculados por filial (dados filtrados):")
print(f"üìä Total de registros: {df_pct_telefonia_filtrado.count():,}")

df_pct_telefonia_filtrado.limit(5).display()

# COMMAND ----------

# MAGIC %md
# MAGIC ## 9. Resumo da Detec√ß√£o de Meses At√≠picos

# MAGIC %md
# MAGIC Apresentamos um resumo completo da detec√ß√£o e remo√ß√£o de meses at√≠picos,
# MAGIC incluindo estat√≠sticas e impacto na base de dados.

# COMMAND ----------

# Estat√≠sticas finais
total_registros_original = df_vendas_estoque_telefonia_gemeos_modelos.count()
total_registros_filtrado = df_vendas_estoque_telefonia_filtrado.count()
total_meses_original = df_vendas_estoque_telefonia_gemeos_modelos.select("year_month").distinct().count()
total_meses_filtrado = df_vendas_estoque_telefonia_filtrado.select("year_month").distinct().count()

print("üìã RESUMO COMPLETO DA DETEC√á√ÉO DE MESES AT√çPICOS")
print("=" * 80)

print(f"\nüìä IMPACTO NA BASE DE DADOS:")
print(f"  ‚Ä¢ Registros originais: {total_registros_original:,}")
print(f"  ‚Ä¢ Registros ap√≥s filtro: {total_registros_filtrado:,}")
print(f"  ‚Ä¢ Registros removidos: {total_registros_original - total_registros_filtrado:,}")
print(f"  ‚Ä¢ Percentual de remo√ß√£o: {((total_registros_original - total_registros_filtrado) / total_registros_original * 100):.2f}%")

print(f"\nüìÖ IMPACTO NOS MESES:")
print(f"  ‚Ä¢ Meses originais: {total_meses_original}")
print(f"  ‚Ä¢ Meses ap√≥s filtro: {total_meses_filtrado}")
print(f"  ‚Ä¢ Meses removidos: {total_meses_original - total_meses_filtrado}")

print(f"\nüîç MESES AT√çPICOS REMOVIDOS:")
if meses_atipicos_lista:
    for mes in sorted(meses_atipicos_lista):
        print(f"  ‚Ä¢ {mes}")
else:
    print("  ‚Ä¢ Nenhum m√™s at√≠pico identificado")

print(f"\n‚úÖ RESULTADO:")
print(f"  ‚Ä¢ Base limpa para c√°lculo da matriz de merecimento")
print(f"  ‚Ä¢ Remo√ß√£o autom√°tica de outliers estat√≠sticos")
print(f"  ‚Ä¢ Melhoria na qualidade das aloca√ß√µes calculadas")

# COMMAND ----------

# MAGIC %md
# MAGIC ## 10. Pr√≥ximos Passos

# MAGIC %md
# MAGIC A base de dados est√° agora limpa e pronta para o c√°lculo da matriz de merecimento.
# MAGIC Os pr√≥ximos passos incluem:

# COMMAND ----------

print("üéØ PR√ìXIMOS PASSOS PARA C√ÅLCULO DA MATRIZ:")
print("=" * 60)

print(f"\n1Ô∏è‚É£ BASE PREPARADA:")
print(f"   ‚úÖ Dados de vendas e estoque carregados")
print(f"   ‚úÖ Mapeamentos de produtos aplicados")
print(f"   ‚úÖ Meses at√≠picos removidos automaticamente")
print(f"   ‚úÖ Estat√≠sticas validadas")

print(f"\n2Ô∏è‚É£ PR√ìXIMAS ETAPAS:")
print(f"   üìä C√°lculo da matriz de merecimento por filial")
print(f"   üìä Otimiza√ß√£o das aloca√ß√µes")
print(f"   üìä Valida√ß√£o dos resultados")
print(f"   üìä Gera√ß√£o de relat√≥rios")

print(f"\n3Ô∏è‚É£ ARQUIVOS DE SA√çDA:")
print(f"   üìÅ Matriz de merecimento otimizada")
print(f"   üìÅ Relat√≥rio de meses removidos")
print(f"   üìÅ Estat√≠sticas de qualidade")

print(f"\n‚úÖ Notebook de detec√ß√£o de meses at√≠picos conclu√≠do com sucesso!")
print(f"üéØ Base pronta para c√°lculo da matriz de merecimento!")


